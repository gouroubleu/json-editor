const puppeteer = require('puppeteer');
const fs = require('fs').promises;
const path = require('path');

/**
 * Test Puppeteer - Diagnostic probl√®me propri√©t√©s JSON Schema c√¥t√© administration
 *
 * Ce script teste l'ajout de propri√©t√©s de type "jsonschema" dans l'interface
 * d'administration sur http://localhost:5501/edit/test-user/
 *
 * Objectifs:
 * 1. Reproduire pr√©cis√©ment le probl√®me avec les propri√©t√©s jsonschema
 * 2. Capturer tous les erreurs console/r√©seau
 * 3. Documenter le comportement exact de l'interface
 * 4. Identifier les composants d√©faillants
 */

const TEST_CONFIG = {
  baseUrl: 'http://localhost:5501',
  schemaPath: '/edit/test-user',
  headless: true, // Mode headless pour environment sans GUI
  slowMo: 200, // Ralentir les actions pour observation
  timeout: 30000,
  screenshotDir: './CLAUDE/screenshots'
};

class JsonSchemaAdminTester {
  constructor() {
    this.browser = null;
    this.page = null;
    this.errors = [];
    this.networkIssues = [];
    this.consoleMessages = [];
    this.testResults = {
      timestamp: new Date().toISOString(),
      success: false,
      errors: [],
      screenshots: [],
      phase: '',
      details: {}
    };
  }

  async init() {
    console.log('üöÄ Initialisation du test Puppeteer pour JSONSchema Admin...');

    // Cr√©er le dossier screenshots si n√©cessaire
    try {
      await fs.mkdir(TEST_CONFIG.screenshotDir, { recursive: true });
    } catch (error) {
      console.log('üìÅ Dossier screenshots d√©j√† existant');
    }

    this.browser = await puppeteer.launch({
      headless: TEST_CONFIG.headless,
      slowMo: TEST_CONFIG.slowMo,
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
      defaultViewport: { width: 1400, height: 900 }
    });

    this.page = await this.browser.newPage();

    // √âcouter les erreurs console
    this.page.on('console', (msg) => {
      const message = {
        type: msg.type(),
        text: msg.text(),
        timestamp: new Date().toISOString()
      };
      this.consoleMessages.push(message);

      if (msg.type() === 'error') {
        console.log('‚ùå Erreur console:', msg.text());
        this.errors.push(`Console Error: ${msg.text()}`);
      }
    });

    // √âcouter les erreurs de page
    this.page.on('pageerror', (error) => {
      console.log('üí• Erreur page:', error.message);
      this.errors.push(`Page Error: ${error.message}`);
    });

    // √âcouter les √©checs de requ√™tes
    this.page.on('requestfailed', (request) => {
      const networkIssue = {
        url: request.url(),
        failure: request.failure()?.errorText,
        timestamp: new Date().toISOString()
      };
      this.networkIssues.push(networkIssue);
      console.log('üåê Requ√™te √©chou√©e:', request.url(), request.failure()?.errorText);
    });

    // √âcouter les r√©ponses d'erreur
    this.page.on('response', (response) => {
      if (response.status() >= 400) {
        const networkIssue = {
          url: response.url(),
          status: response.status(),
          statusText: response.statusText(),
          timestamp: new Date().toISOString()
        };
        this.networkIssues.push(networkIssue);
        console.log(`üö´ R√©ponse erreur ${response.status()}:`, response.url());
      }
    });
  }

  async takeScreenshot(name, description) {
    const filename = `${name}-${Date.now()}.png`;
    const filepath = path.join(TEST_CONFIG.screenshotDir, filename);

    await this.page.screenshot({
      path: filepath,
      fullPage: true
    });

    this.testResults.screenshots.push({
      name,
      description,
      filename,
      filepath,
      timestamp: new Date().toISOString()
    });

    console.log(`üì∏ Screenshot: ${filename} - ${description}`);
    return filepath;
  }

  async navigateToAdminPage() {
    console.log('üß≠ Navigation vers la page d\'administration...');
    this.testResults.phase = 'navigation';

    const fullUrl = `${TEST_CONFIG.baseUrl}${TEST_CONFIG.schemaPath}`;
    console.log(`üìç URL cible: ${fullUrl}`);

    try {
      await this.page.goto(fullUrl, {
        waitUntil: 'networkidle2',
        timeout: TEST_CONFIG.timeout
      });

      await this.takeScreenshot('01-page-loaded', 'Page d\'administration charg√©e');

      // V√©rifier que la page est bien charg√©e
      const title = await this.page.title();
      console.log(`üìÑ Titre de la page: ${title}`);

      // Attendre que l'interface soit pr√™te
      await this.page.waitForSelector('.edit-schema-page, .horizontal-schema-editor', {
        timeout: 10000
      });

      console.log('‚úÖ Page d\'administration charg√©e avec succ√®s');
      return true;

    } catch (error) {
      this.errors.push(`Navigation failed: ${error.message}`);
      console.log('‚ùå √âchec de navigation:', error.message);
      await this.takeScreenshot('01-navigation-error', 'Erreur de navigation');
      return false;
    }
  }

  async analyzeCurrentInterface() {
    console.log('üîç Analyse de l\'interface actuelle...');
    this.testResults.phase = 'interface_analysis';

    try {
      // Capturer l'√©tat initial
      await this.takeScreenshot('02-interface-initial', '√âtat initial de l\'interface');

      // Analyser les composants pr√©sents
      const interfaceElements = await this.page.evaluate(() => {
        const analysis = {
          schemaEditor: !!document.querySelector('.horizontal-schema-editor'),
          propertyColumns: document.querySelectorAll('.property-column').length,
          addButtons: document.querySelectorAll('button[class*="add"], .add-property').length,
          selectElements: document.querySelectorAll('select').length,
          totalButtons: document.querySelectorAll('button').length,
          totalInputs: document.querySelectorAll('input').length,
          errorElements: document.querySelectorAll('.error, .alert-danger').length
        };

        // Analyser les options de type disponibles
        const typeSelects = Array.from(document.querySelectorAll('select')).filter(select => {
          return Array.from(select.options).some(option =>
            option.value.includes('type') || option.text.includes('Type')
          );
        });

        const availableTypes = [];
        typeSelects.forEach(select => {
          Array.from(select.options).forEach(option => {
            if (option.value && option.value !== '') {
              availableTypes.push({
                value: option.value,
                text: option.text,
                selected: option.selected
              });
            }
          });
        });

        analysis.availableTypes = availableTypes;
        analysis.typeSelectsFound = typeSelects.length;

        return analysis;
      });

      this.testResults.details.interfaceAnalysis = interfaceElements;
      console.log('üìä Analyse interface:', JSON.stringify(interfaceElements, null, 2));

      // V√©rifier sp√©cifiquement la pr√©sence du type "jsonschema"
      const hasJsonSchemaType = interfaceElements.availableTypes.some(type =>
        type.value === 'jsonschema' || type.text.toLowerCase().includes('json schema')
      );

      console.log(`üîç Type "jsonschema" disponible: ${hasJsonSchemaType ? '‚úÖ' : '‚ùå'}`);
      this.testResults.details.jsonSchemaTypeAvailable = hasJsonSchemaType;

      return interfaceElements;

    } catch (error) {
      this.errors.push(`Interface analysis failed: ${error.message}`);
      console.log('‚ùå √âchec analyse interface:', error.message);
      return null;
    }
  }

  async attemptAddJsonSchemaProperty() {
    console.log('‚ûï Tentative d\'ajout d\'une propri√©t√© JSON Schema...');
    this.testResults.phase = 'add_jsonschema_property';

    try {
      // Chercher un bouton d'ajout de propri√©t√©
      const addButtons = await this.page.$$('button');
      let addPropertyButton = null;

      for (const button of addButtons) {
        const text = await this.page.evaluate(el => el.textContent?.toLowerCase() || '', button);
        if (text.includes('add') || text.includes('ajouter') || text.includes('+')) {
          addPropertyButton = button;
          console.log(`üéØ Bouton d'ajout trouv√©: "${text}"`);
          break;
        }
      }

      if (!addPropertyButton) {
        throw new Error('Aucun bouton d\'ajout de propri√©t√© trouv√©');
      }

      // Cliquer sur le bouton d'ajout
      await this.takeScreenshot('03-before-add-click', 'Avant clic bouton ajout');
      await addPropertyButton.click();
      await new Promise(resolve => setTimeout(resolve, 1000));
      await this.takeScreenshot('04-after-add-click', 'Apr√®s clic bouton ajout');

      // Chercher les champs de cr√©ation de propri√©t√©
      const propertyNameInput = await this.page.$('input[placeholder*="nom"], input[placeholder*="name"], input[name*="name"]');
      const typeSelect = await this.page.$('select option[value="jsonschema"]')?.then(option =>
        option ? this.page.$('select') : null
      );

      if (!propertyNameInput) {
        throw new Error('Champ nom de propri√©t√© non trouv√©');
      }

      // Saisir un nom de propri√©t√©
      await propertyNameInput.click();
      await propertyNameInput.clear();
      await propertyNameInput.type('test-jsonschema-property');
      await this.takeScreenshot('05-property-name-entered', 'Nom de propri√©t√© saisi');

      // Chercher et s√©lectionner le type jsonschema
      console.log('üîç Recherche de l\'option jsonschema...');

      const jsonSchemaSelection = await this.page.evaluate(() => {
        const selects = Array.from(document.querySelectorAll('select'));

        for (const select of selects) {
          const jsonSchemaOption = Array.from(select.options).find(option =>
            option.value === 'jsonschema' || option.text.toLowerCase().includes('json schema')
          );

          if (jsonSchemaOption) {
            // Tenter la s√©lection
            select.value = jsonSchemaOption.value;
            jsonSchemaOption.selected = true;

            // D√©clencher les √©v√©nements
            select.dispatchEvent(new Event('change', { bubbles: true }));
            select.dispatchEvent(new Event('input', { bubbles: true }));

            return {
              success: true,
              selectedValue: jsonSchemaOption.value,
              selectedText: jsonSchemaOption.text,
              selectElement: select.className || select.id || 'select-element'
            };
          }
        }

        return {
          success: false,
          error: 'Option jsonschema non trouv√©e',
          availableOptions: selects.map(select =>
            Array.from(select.options).map(opt => ({ value: opt.value, text: opt.text }))
          ).flat()
        };
      });

      this.testResults.details.jsonSchemaSelection = jsonSchemaSelection;
      console.log('üìã R√©sultat s√©lection jsonschema:', JSON.stringify(jsonSchemaSelection, null, 2));

      if (jsonSchemaSelection.success) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        await this.takeScreenshot('06-jsonschema-selected', 'Type jsonschema s√©lectionn√©');

        // Analyser ce qui se passe apr√®s la s√©lection
        await this.analyzePostSelectionState();

      } else {
        console.log('‚ùå Impossible de s√©lectionner le type jsonschema');
        await this.takeScreenshot('06-jsonschema-selection-failed', '√âchec s√©lection jsonschema');
        this.errors.push('JsonSchema type selection failed: ' + jsonSchemaSelection.error);
      }

      return jsonSchemaSelection.success;

    } catch (error) {
      this.errors.push(`Add jsonschema property failed: ${error.message}`);
      console.log('‚ùå √âchec ajout propri√©t√© jsonschema:', error.message);
      await this.takeScreenshot('06-add-property-error', 'Erreur ajout propri√©t√©');
      return false;
    }
  }

  async analyzePostSelectionState() {
    console.log('üî¨ Analyse de l\'√©tat apr√®s s√©lection jsonschema...');

    try {
      const postSelectionState = await this.page.evaluate(() => {
        const analysis = {
          timestamp: new Date().toISOString(),
          newElementsVisible: {},
          configurationFields: [],
          validationMessages: [],
          enabledButtons: 0,
          disabledButtons: 0
        };

        // Chercher les nouveaux √©l√©ments de configuration
        const possibleConfigElements = [
          { selector: '.jsonschema-config', description: 'Configuration JSONSchema' },
          { selector: '.reference-config', description: 'Configuration r√©f√©rence' },
          { selector: 'input[placeholder*="schema"]', description: 'Champ sch√©ma' },
          { selector: 'select[name*="schema"]', description: 'S√©lecteur sch√©ma' },
          { selector: '.schema-selector', description: 'S√©lecteur de sch√©ma' },
          { selector: '.ref-metadata', description: 'M√©tadonn√©es r√©f√©rence' }
        ];

        possibleConfigElements.forEach(({ selector, description }) => {
          const elements = document.querySelectorAll(selector);
          analysis.newElementsVisible[description] = elements.length;

          if (elements.length > 0) {
            elements.forEach((el, index) => {
              analysis.configurationFields.push({
                description: `${description} ${index + 1}`,
                tagName: el.tagName,
                className: el.className,
                placeholder: el.placeholder || '',
                visible: el.offsetParent !== null
              });
            });
          }
        });

        // Analyser les messages de validation/erreur
        const errorSelectors = ['.error', '.alert-danger', '.validation-error', '.warning'];
        errorSelectors.forEach(selector => {
          const errorElements = document.querySelectorAll(selector);
          errorElements.forEach(el => {
            if (el.textContent?.trim()) {
              analysis.validationMessages.push({
                type: 'error',
                message: el.textContent.trim(),
                selector: selector
              });
            }
          });
        });

        // Compter les boutons actifs/inactifs
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
          if (button.disabled) {
            analysis.disabledButtons++;
          } else {
            analysis.enabledButtons++;
          }
        });

        return analysis;
      });

      this.testResults.details.postSelectionState = postSelectionState;
      console.log('üìä √âtat post-s√©lection:', JSON.stringify(postSelectionState, null, 2));

      await this.takeScreenshot('07-post-selection-analysis', 'Analyse apr√®s s√©lection jsonschema');

      // Chercher sp√©cifiquement les composants JsonSchemaReferenceField
      const jsonSchemaComponents = await this.page.evaluate(() => {
        const components = {
          jsonSchemaReferenceFields: [],
          referenceConfigColumns: [],
          possibleConfigElements: []
        };

        // Chercher les √©l√©ments avec classes sp√©cifiques au JsonSchema
        const classNames = [
          'jsonschema-field',
          'reference-header',
          'reference-config',
          'schema-selector',
          'reference-content'
        ];

        classNames.forEach(className => {
          const elements = document.getElementsByClassName(className);
          if (elements.length > 0) {
            components.jsonSchemaReferenceFields.push({
              className: className,
              count: elements.length,
              visible: Array.from(elements).some(el => el.offsetParent !== null)
            });
          }
        });

        return components;
      });

      this.testResults.details.jsonSchemaComponents = jsonSchemaComponents;
      console.log('üß© Composants JsonSchema d√©tect√©s:', JSON.stringify(jsonSchemaComponents, null, 2));

    } catch (error) {
      console.log('‚ùå Erreur analyse post-s√©lection:', error.message);
      this.errors.push(`Post-selection analysis failed: ${error.message}`);
    }
  }

  async testSaveAttempt() {
    console.log('üíæ Test de tentative de sauvegarde...');
    this.testResults.phase = 'save_attempt';

    try {
      // Chercher un bouton de sauvegarde
      const saveButtons = await this.page.$$('button');
      let saveButton = null;

      for (const button of saveButtons) {
        const text = await this.page.evaluate(el => el.textContent?.toLowerCase() || '', button);
        if (text.includes('save') || text.includes('sauv') || text.includes('enregistrer')) {
          saveButton = button;
          console.log(`üíæ Bouton sauvegarde trouv√©: "${text}"`);
          break;
        }
      }

      if (!saveButton) {
        console.log('‚ö†Ô∏è Aucun bouton de sauvegarde trouv√©');
        return false;
      }

      // V√©rifier si le bouton est activ√©
      const isEnabled = await this.page.evaluate(btn => !btn.disabled, saveButton);
      console.log(`üîò Bouton sauvegarde ${isEnabled ? 'activ√©' : 'd√©sactiv√©'}`);

      await this.takeScreenshot('08-before-save', 'Avant tentative de sauvegarde');

      if (isEnabled) {
        await saveButton.click();
        await new Promise(resolve => setTimeout(resolve, 2000));
        await this.takeScreenshot('09-after-save-click', 'Apr√®s clic sauvegarde');

        // Analyser le r√©sultat de la sauvegarde
        const saveResult = await this.page.evaluate(() => {
          const notifications = Array.from(document.querySelectorAll('.notification, .alert, .message'));
          const errors = Array.from(document.querySelectorAll('.error, .alert-danger'));

          return {
            notifications: notifications.map(el => ({
              text: el.textContent?.trim() || '',
              className: el.className
            })),
            errors: errors.map(el => ({
              text: el.textContent?.trim() || '',
              className: el.className
            })),
            currentUrl: window.location.href
          };
        });

        this.testResults.details.saveResult = saveResult;
        console.log('üìÑ R√©sultat sauvegarde:', JSON.stringify(saveResult, null, 2));
      }

      return isEnabled;

    } catch (error) {
      this.errors.push(`Save attempt failed: ${error.message}`);
      console.log('‚ùå √âchec tentative sauvegarde:', error.message);
      await this.takeScreenshot('09-save-error', 'Erreur sauvegarde');
      return false;
    }
  }

  async generateTestReport() {
    console.log('üìã G√©n√©ration du rapport de test...');

    this.testResults.success = this.errors.length === 0;
    this.testResults.errors = this.errors;
    this.testResults.networkIssues = this.networkIssues;
    this.testResults.consoleMessages = this.consoleMessages.filter(msg => msg.type === 'error');
    this.testResults.completedAt = new Date().toISOString();
    this.testResults.duration = new Date() - new Date(this.testResults.timestamp);

    // Analyse des probl√®mes identifi√©s
    this.testResults.problemAnalysis = {
      criticalIssues: [],
      warnings: [],
      recommendations: []
    };

    // Identifier les probl√®mes critiques
    if (!this.testResults.details.jsonSchemaTypeAvailable) {
      this.testResults.problemAnalysis.criticalIssues.push(
        'Type "jsonschema" non disponible dans les options de type de propri√©t√©'
      );
    }

    if (this.testResults.details.jsonSchemaSelection && !this.testResults.details.jsonSchemaSelection.success) {
      this.testResults.problemAnalysis.criticalIssues.push(
        'Impossible de s√©lectionner le type jsonschema dans l\'interface'
      );
    }

    if (this.errors.length > 0) {
      this.testResults.problemAnalysis.criticalIssues.push(
        `${this.errors.length} erreur(s) d√©tect√©e(s) pendant les tests`
      );
    }

    // Ajouter des recommandations
    if (this.testResults.details.jsonSchemaComponents?.jsonSchemaReferenceFields?.length === 0) {
      this.testResults.problemAnalysis.recommendations.push(
        'V√©rifier que le composant JsonSchemaReferenceField est correctement int√©gr√©'
      );
    }

    if (this.networkIssues.length > 0) {
      this.testResults.problemAnalysis.warnings.push(
        `${this.networkIssues.length} probl√®me(s) r√©seau d√©tect√©(s)`
      );
    }

    // Sauvegarder le rapport
    const reportPath = path.join('./CLAUDE', 'test-jsonschema-admin-rapport.json');
    await fs.writeFile(reportPath, JSON.stringify(this.testResults, null, 2));

    console.log('üìä Rapport de test sauvegard√©:', reportPath);
    return this.testResults;
  }

  async cleanup() {
    console.log('üßπ Nettoyage...');
    if (this.browser) {
      await this.browser.close();
    }
  }

  async run() {
    try {
      await this.init();

      console.log('\n=== PHASE 1: NAVIGATION ===');
      const navigationSuccess = await this.navigateToAdminPage();

      if (!navigationSuccess) {
        throw new Error('√âchec de navigation - test arr√™t√©');
      }

      console.log('\n=== PHASE 2: ANALYSE INTERFACE ===');
      await this.analyzeCurrentInterface();

      console.log('\n=== PHASE 3: AJOUT PROPRI√âT√â JSONSCHEMA ===');
      await this.attemptAddJsonSchemaProperty();

      console.log('\n=== PHASE 4: TEST SAUVEGARDE ===');
      await this.testSaveAttempt();

      console.log('\n=== PHASE 5: G√âN√âRATION RAPPORT ===');
      const report = await this.generateTestReport();

      // Afficher le r√©sum√©
      console.log('\n' + '='.repeat(60));
      console.log('üìã R√âSUM√â DU TEST');
      console.log('='.repeat(60));
      console.log(`‚úÖ Succ√®s global: ${report.success ? 'OUI' : 'NON'}`);
      console.log(`‚ùå Erreurs d√©tect√©es: ${report.errors.length}`);
      console.log(`üåê Probl√®mes r√©seau: ${report.networkIssues.length}`);
      console.log(`üì∏ Screenshots captur√©s: ${report.screenshots.length}`);
      console.log(`‚è±Ô∏è Dur√©e du test: ${Math.round(report.duration / 1000)}s`);

      if (report.problemAnalysis.criticalIssues.length > 0) {
        console.log('\nüö® PROBL√àMES CRITIQUES:');
        report.problemAnalysis.criticalIssues.forEach((issue, index) => {
          console.log(`  ${index + 1}. ${issue}`);
        });
      }

      if (report.problemAnalysis.recommendations.length > 0) {
        console.log('\nüí° RECOMMANDATIONS:');
        report.problemAnalysis.recommendations.forEach((rec, index) => {
          console.log(`  ${index + 1}. ${rec}`);
        });
      }

      console.log('\nüìÇ Fichiers g√©n√©r√©s:');
      console.log(`  üìÑ Rapport: ./CLAUDE/test-jsonschema-admin-rapport.json`);
      console.log(`  üìÅ Screenshots: ${TEST_CONFIG.screenshotDir}/`);

      return report;

    } catch (error) {
      console.log('üí• Erreur critique:', error.message);
      this.errors.push(`Critical error: ${error.message}`);
      await this.takeScreenshot('critical-error', 'Erreur critique du test');
      return await this.generateTestReport();
    } finally {
      await this.cleanup();
    }
  }
}

// Ex√©cution du test
async function main() {
  console.log('üß™ TEST DIAGNOTIC JSONSCHEMA ADMINISTRATION');
  console.log('='.repeat(60));
  console.log(`üåê URL cible: ${TEST_CONFIG.baseUrl}${TEST_CONFIG.schemaPath}`);
  console.log(`üìÅ Screenshots: ${TEST_CONFIG.screenshotDir}`);
  console.log(`‚è±Ô∏è Timeout: ${TEST_CONFIG.timeout}ms`);
  console.log('='.repeat(60));

  const tester = new JsonSchemaAdminTester();
  const results = await tester.run();

  console.log('\nüèÅ Test termin√©!');
  process.exit(results.success ? 0 : 1);
}

if (require.main === module) {
  main().catch(error => {
    console.error('üí• Erreur fatale:', error);
    process.exit(1);
  });
}

module.exports = { JsonSchemaAdminTester, TEST_CONFIG };